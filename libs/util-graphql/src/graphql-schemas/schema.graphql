scalar Timestamp

schema {
  query: Query
}

type Query {
  me: User!
  user(address: String!, currency: String! = "USD"): User
  allUsers: [User]
  token(symbol: String!): TokenEntity
  tokens: [TokenEntity]
  tokensBySymbol(symbols: [String!]!): [TokenEntity]
  vaults(currency: String! = "USD"): [YieldVaultEntity]
}

type User {
  address: String!
  pieVaults: [UserTokenEntity!]!
  twentyFourHourChange: PriceChange!
  yieldVaults: [UserYieldVaultEntity!]!
  totalBalance: Float!
  profit: Float!
  performance: Float!
}

type MarketDataEntity {
  circulatingSupply: Float!
  currentPrice(currency: String! = "USD"): Float!
  marketCap: String!
  marketCapRank: Float!
  timestamp: Timestamp!
  totalVolume: String!
  twentyFourHourChange: PriceChange!
  fromInception: Float!
  discount: Float!
  interests: Float!
  nav: Float!
}

interface TokenInterface {
  address: String!
  chain: String!
  coinGeckoId: String!
  decimals: Float!
  kind: String!
  marketData: [MarketDataEntity!]!
  name: String!
  symbol: String!
  riskGrade: String!
}

type TokenEntity implements TokenInterface {
  address: String!
  chain: String!
  coinGeckoId: String!
  decimals: Float!
  kind: String!
  marketData: [MarketDataEntity!]!
  name: String!
  symbol: String!
  riskGrade: String!
}

type UserTokenEntity implements TokenInterface {
  address: String!
  chain: String!
  coinGeckoId: String!
  decimals: Float!
  kind: String!
  marketData: [MarketDataEntity!]!
  name: String!
  symbol: String!
  riskGrade: String!
}

interface YieldVaultInterface {
  symbol: String!
  name: String!
}

type YieldVaultEntity implements YieldVaultInterface {
  underlyingToken: TokenEntity!
  symbol: String!
  name: String!
  address: String!
}

type UserYieldVaultEntity implements YieldVaultInterface {
  symbol: String!
  name: String!
  address: String!
  twentyFourHourEarnings: Float!
  totalEarnings: Float!
}

type PriceChange {
  price: Float!
  change: Float!
}
