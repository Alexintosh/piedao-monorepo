# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type GovernanceEntity {
  status: String!
  timestamp: String!
  title: String!
  url: String!
}

type Interests {
  apr: Float!
  apy: Float!
}

"""Contains market information for a given token at a specific timestamp."""
type MarketDataEntity {
  allTimeHigh: Float
  allTimeLow: Float
  currentPrice: Float!

  """
  The premium or the discount between price and nav. Positive is premium, negative is discount.
  """
  deltaToNav: Float!

  """
  The performance (%) from the creation of the pie until today. All pies start at $1, so the performance is the nav.
  """
  fromInception: Float!
  interests: Interests!

  """AKA streaming fee is an annualized fee for the pie."""
  managementFee: Float

  """Total supply * nav."""
  marketCap: Float!

  """
  Nav is the difference between the price of the token and the aggregated price of its unerlyings.
  """
  nav: Float!

  """
  The number of users that are holding this token. (defaults to `0` if not available)
  """
  numberOfHolders: Int!
  swapFee: Float
  totalSupply: Float!
  twentyFourHourChange: PriceChange!
}

input MarketDataFilter {
  limit: Int
  orderBy: [MarketDataOrderBy!]
}

input MarketDataOrderBy {
  field: MarketDataOrderByField!
  value: Order!
}

enum MarketDataOrderByField {
  timestamp
}

enum Order {
  asc
  desc
}

type PieVaultEntity {
  address: String!

  """The chain on which this token lives."""
  chain: String!
  currency: String!
  decimals: Int!
  governance: [GovernanceEntity!]!
  inceptionDate: String!

  """The kind of this token (eg: 'PieVault', 'YieldVault', etc)."""
  kind: String!

  """Market data for this token."""
  marketData: [MarketDataEntity!]!
  name: String!
  riskGrade: String!
  symbol: String!
  underlyingTokens: [PieVaultEntity!]!
}

type PriceChange {
  change: Float
  price: Float
}

type Query {
  """Returns all tokens regardless of their kind."""
  tokens(filters: TokenFiltersInput): [TokenEntity!]!

  """Returns all pie vaults."""
  vaults(currency: String!, filters: TokenFiltersInput): [PieVaultEntity!]!
}

type TokenEntity {
  address: String!

  """The chain on which this token lives."""
  chain: String!
  coinGeckoId: String!
  decimals: Float!

  """The kind of this token (eg: 'PieVault', 'YieldVault', etc)."""
  kind: String!

  """Market data for this token."""
  marketData: [MarketDataEntity!]!
  name: String!
  symbol: String!
}

input TokenFilter {
  limit: Int
  orderBy: [TokenOrderBy!]
}

input TokenFiltersInput {
  marketData: MarketDataFilter = {}
  token: TokenFilter = {}
}

input TokenOrderBy {
  field: TokenOrderByField!
  value: Order!
}

enum TokenOrderByField {
  name
  symbol
}